snippet testclass "Test Class Template"

using NUnit.Framework;

namespace ${1:ModuleName}.Tests
{
    public class ${2:ClassName}
    {
        $0
    }
}
endsnippet

snippet tc "Nunit Test Case"

[Test]
public void ${1:FunctionName}_When${2:Condition}_Should${3:DoSomething}()
{
    //Arrange
    $0
    //Act

    //Assert
    throw new Exception();
}
endsnippet

snippet exception "Exception"
[System.Serializable]
public class ${1:ExceptionName} : System.Exception
{
    public $1() { }
    public $1(string message) : base(message) { }
    public $1(string message, System.Exception inner) : base(message, inner) { }
    protected $1(
      System.Runtime.Serialization.SerializationInfo info,
      System.Runtime.Serialization.StreamingContext context) : base(info, context) { }
}
endsnippet

snippet	propp "Prism Property"
    private ${1:type} ${2:name};
    public $1 `!p snip.rv = t[2][0].upper() + t[2][1:]`
    {
       get { return $2; }
       set { SetProperty(ref $2, value); }
    }
endsnippet

snippet propdp "Dependency Property" -b

public ${1:int} ${2:MyProperty}
{
    get { return ($1)GetValue($2Property); }
    set { SetValue($2Property, value); }
}

// Using a DependencyProperty as the backing store for $2.  This enables animation, styling, binding, etc...
public static readonly DependencyProperty $2Property =
    DependencyProperty.Register("$2", typeof($1), typeof(${3:owning_class}), new PropertyMetadata(${4:default_value}));
endsnippet


snippet logclass "Class with ILogger"
using Microsoft.Extensions.Logging;

namespace ${2:namespace}
{
    public class ${1:Class_Name}
    {
        private readonly ILogger<$1> logger;

        public $1(ILogger<$1> logger)
        {
            this.logger = logger;
        }
	$0

    }
}
endsnippet

snippet setup "Test Setup" -b
[SetUp]
public void Setup()
{
	$0
}
endsnippet

snippet "(?<=\.)todict" "Convert to dictionary" -r
ToDictionary(kvp => ${1:kvp.Key}, kvp => ${2:kvp.Value})$0
endsnippet

snippet cmd "Prism Command" -b
private DelegateCommand _`!p snip.rv = t[1][0].lower() + t[1][1:] if t[1] else ''`;
public DelegateCommand ${1:CommandName} =>
    _`!p snip.rv = t[1][0].lower() + t[1][1:] if t[1] else ''` ?? (_`!p snip.rv = t[1][0].lower() + t[1][1:] if t[1] else ''` = new DelegateCommand(Execute$1));

void Execute$1()
{
	$0
}
endsnippet

snippet cmdg "Prism Command with generic parameter" -b
private DelegateCommand<${2:param_type}> _`!p snip.rv = t[1][0].lower() + t[1][1:] if t[1] else ''`;
public DelegateCommand<$2> ${1:CommandName} =>
    _`!p snip.rv = t[1][0].lower() + t[1][1:] if t[1] else ''` ?? (_`!p snip.rv = t[1][0].lower() + t[1][1:] if t[1] else ''` = new DelegateCommand<$2>(Execute$1));

void Execute$1($2 ${3:Param_name})
{
	$0
}
endsnippet

snippet cmdfull "Prism Command with CanExecute" -b
private DelegateCommand _`!p snip.rv = t[1][0].lower() + t[1][1:] if t[1] else ''`;
public DelegateCommand ${1:CommandName} =>
    _`!p snip.rv = t[1][0].lower() + t[1][1:] if t[1] else ''` ?? (_`!p snip.rv = t[1][0].lower() + t[1][1:] if t[1] else ''` = new DelegateCommand(Execute$1, CanExecute$1));

void Execute$1()
{
	$0
}

bool CanExecute$1()
{
	return true;
}
endsnippet

snippet cmdgfull "Prism Command with CanExecute and generic parameter" -b
private DelegateCommand<${2:param_type}> _`!p snip.rv = t[1][0].lower() + t[1][1:] if t[1] else ''`;
public DelegateCommand<$2> ${1:CommandName} =>
    _`!p snip.rv = t[1][0].lower() + t[1][1:] if t[1] else ''` ?? (_`!p snip.rv = t[1][0].lower() + t[1][1:] if t[1] else ''` = new DelegateCommand<$2>(Execute$1, CanExecute$1));

void Execute$1($2 ${3:Param_name})
{
	$0
}

bool CanExecute$1($2 $3)
{
	return true;
}
endsnippet

snippet obs "Obsolete Statement" -b
[Obsolete("${1:Migration note}")]
endsnippet

snippet mock "Mock object" -b
mock$1 = new Mock<${1:Type}>();
$0
endsnippet

snippet mockl "Mock Logger" -b
mockLogger = new Mock<ILogger<${1:Type}>>();
$0
endsnippet



snippet valueconverter "IValueConverter implementation" -b
using System;
using System.Globalization;
using System.Windows.Data;

namespace ${1:namespace}
{
    public class ${2:MyConverter} : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            ${3:// TODO: implement conversion logic}
            return ${4:null};
        }
    
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotSupportedException();
        }
    }
}
endsnippet


snippet multivalueconverter "IMultiValueConverter implementation" -b
using System;
using System.Globalization;
using System.Windows.Data;

namespace ${1:namespace}
{
    public class ${2:MyMultiConverter} : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            ${3:// TODO: implement multi-value conversion logic}
            return ${4:null};
        }
    
        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotSupportedException();
        }
    }
}
endsnippet

snippet .Ver "Moq Verify" -i
.Verify(x => x.$0, Times.$1);
endsnippet

